추상 클래스를 "레시피"로 생각해보세요.

**레시피 (Abstract Class)**:

- 레시피는 음식을 만드는 방법을 알려줍니다. 하지만 레시피 자체로는 음식을 먹을 수 없어요. 예를 들어, "케이크 레시피"는 케이크를 만드는 방법을 알려주지만, 레시피만으로는 케이크를 만들 수 없습니다. 마찬가지로, 추상 클래스는 메서드의 '선언'(방법)을 제공하지만, 그 자체로는 객체를 생성할 수 없습니다.

**구체적인 음식 (Concrete Class)**:

- 구체적인 음식, 예를 들어 "딸기 케이크"나 "초콜릿 케이크"는 레시피를 바탕으로 실제로 만들어질 수 있습니다. 이것은 추상 클래스에서 파생된 구체적인 클래스(Concrete Class)와 같습니다. 이 클래스들은 추상 클래스에서 정의된 메서드들을 '구현'하여 실제 객체를 만들 수 있게 합니다.

**레시피의 필수 단계 (Abstract Method)**:

- 레시피에는 "반죽하기", "오븐에 굽기" 같은 필수 단계가 있을 수 있습니다. 이러한 단계는 모든 케이크 만들기에 필요하지만, 각 케이크마다 조금씩 다를 수 있어요. 예를 들어, 딸기 케이크의 반죽은 딸기가 들어가고, 초콜릿 케이크는 초콜릿이 들어갑니다. 추상 클래스의 추상 메서드(Abstract Method)도 비슷해요. 추상 메서드는 메서드의 '선언'만 있고, 실제 '구현'은 파생 클래스에서 달라집니다.

결론적으로, 추상 클래스는 어떤 것의 기본적인 형태와 필수적인 부분을 정의해놓은 '레시피' 같은 것입니다. 이를 바탕으로 실제 작동하는 구체적인 클래스들이 만들어지죠.


```

using UnityEngine;

// 추상 클래스 정의
public abstract class Animal
{
    // 추상 메서드 정의
    public abstract void Speak();
}

// Dog 클래스는 Animal 클래스를 상속받음
public class Dog : Animal
{
    // Speak 메서드 구현
    public override void Speak()
    {
        Debug.Log("Dog says: Woof!");
    }
}

// Cat 클래스는 Animal 클래스를 상속받음
public class Cat : Animal
{
    // Speak 메서드 구현
    public override void Speak()
    {
        Debug.Log("Cat says: Meow!");
    }
}

// MonoBehaviour를 사용하는 클래스
public class AnimalTester : MonoBehaviour
{
    private void Start()
    {
        // Dog와 Cat 객체 생성
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        // Speak 메서드 호출
        myDog.Speak();
        myCat.Speak();
    }
}


```



일반 클래스를 상속받는 것과 추상 클래스를 상속받는 것 사이에는 몇 가지 주요 차이점이 있습니다:

1. **추상 메서드의 유무**:
    
    - **추상 클래스**: 추상 클래스는 하나 이상의 추상 메서드(구체적인 구현이 없는 메서드)를 포함할 수 있습니다. 이 추상 메서드는 추상 클래스를 상속받는 모든 구체 클래스에서 구현해야 합니다.
    - **일반 클래스**: 일반 클래스는 모든 메서드가 구체적인 구현을 가지고 있습니다. 일반 클래스를 상속받는 클래스는 부모 클래스의 메서드를 오버라이드할 수는 있지만, 이것이 필수는 아닙니다.
2. **인스턴스 생성**:
    
    - **추상 클래스**: 추상 클래스는 직접 인스턴스화될 수 없습니다. 즉, 추상 클래스 자체로는 객체를 생성할 수 없으며, 반드시 먼저 상속받아 구체적인 구현을 제공하는 자식 클래스를 통해야만 인스턴스를 생성할 수 있습니다.
    - **일반 클래스**: 일반 클래스는 자체적으로 인스턴스화될 수 있습니다. 즉, 상속을 받지 않은 상태로도 객체를 생성할 수 있습니다.
3. **설계 목적**:
    
    - **추상 클래스**: 추상 클래스는 주로 공통의 기능을 정의하고 확장을 위한 기반을 제공하는 데 사용됩니다. 이를 통해 코드 재사용성을 높이고, 일관된 설계를 유도할 수 있습니다.
    - **일반 클래스**: 일반 클래스는 바로 사용할 수 있는 기능을 제공하며, 필요에 따라 추가적인 기능을 오버라이드하거나 확장할 수 있는 유연성을 제공합니다.
4. **용도**:
    
    - **추상 클래스**: 추상 클래스는 주로 "무엇을 해야 하는지"에 초점을 맞춥니다. 즉, 파생 클래스가 어떤 메서드를 반드시 구현해야 하는지 지시합니다.
    - **일반 클래스**: 일반 클래스는 "어떻게 해야 하는지"에 초점을 맞춥니다. 즉, 특정 작업을 수행하는 구체적인 방법을 제공합니다.

결국, 추상 클래스와 일반 클래스는 서로 다른 상황과 필요에 따라 선택되며, 객체 지향 프로그래밍에서 각각의 역할과 중요성을 가집니다. 추상 클래스는 일종의 "계약"을 제공하여 파생 클래스가 특정 메서드를 반드시 구현하도록 강제하는 반면, 일반 클래스는 즉시 사용 가능한 기능을 제공합니다.